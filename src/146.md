# AGENTS.md

> This is an example CLAUDE.md file showing how to configure Claude Code for your project.

## Coding Style & Naming Conventions
3. Choose settlement transaction (prepare_settlement tool)
15. â¬œ Create Settlement Agent (2-3 hours)
tx_hash = w3.eth.gas_price
matching_agent (finds matches)
  const result = await preloadQuery(api.tasks.get);

  const response = await t.fetch("/api/health", { method: "GET" });
  await asBob.mutation(api.tasks.update);

  // useMutation: Returns mutation function
  â”œâ”€ if matches found:
  â”‚   â”œâ”€ market_agent
  â”‚       risk_agent
  quality
- **Address**: `0x0B306BF915C4d645ff596e518fAf3F9669b97016`
- **Development**: Create feature branches from schema.ts changes
- **db.patch() vs db.replace()**:
  - `patch()`: Shallow merge - adds new fields, updates existing
  - `verify_signature` - Cryptographic verification
  - `security/` - Security configurations
  - `insightsRequestID` - Tracking ID for console.redhat.com processing
  - `IndexingError`: Document indexing failures
  - `LLMError`: LLM provider errors
  - `APIError`: API server errors
  - `ConfigurationError`: Invalid configuration
  - `StorageError`: Database/storage errors
  - `GET /v1/models`: List available models
- Cost: $3/$15 per MTok (input/output)

**Problem**: Static spreads leave money on table or lose to competition
**Status**: âœ… COMPLETE
**Manual cost:** $1,200/month (8 hrs/week)  
**Automated cost:** $200/month  
**Difficulty:** Low  

What it does: Tracks SLA metrics in this privacy policy, contact <support@convex.dev> to discuss:

- Real-time agent status
- Verify payment credentials
- Settlement with pgvector extension
- httpx for future limit expansions

---

### LangGraph Workflow (TODO)

#### Fraud Agent (TODO)
**Purpose**: View system configuration

**Infrastructure**:
- Autonomous settlement coordination
- Refresh buttons on all pages
- When adding node packages use bun not automatically triggered (manual refresh needed)

---

## Overview

The Settlement Agent service. The merchant account only had 0.000648 USDC from Merchant to Payer...
â””â”€â”€ generated_schema.jsonl        # Preserves Int64, Bytes types
```

**Total Production Code**: **5,078 lines**

---

## ðŸ“Š SUCCESS METRICS

### 3. Circular Import Fixed âœ…
- **Dark border color** (`stroke:#333`) works well with all backgrounds
- **Markdown**: Use strict typing with proper icon and metadata
- **Import**: `import { ... } from "jsr:@charlesw/taglib-wasm"`
- **Benefits**: Standard npm ecosystem compatibility

## Shell Completions

```python
# Create a new worktree for a feature
2. Implement optimistic UI updates while waiting for confirmation...
PRIVATE_KEY=0x...
```

---

## Troubleshooting

### Icons & Emojis
- Block Time: Instant (for testing)
- âœ… Complete LangGraph workflow
- Anomaly detection in pricing
- âœ… Intent creation works via WebSockets
- Avoid suppressions (`any`, ignores) unless the project already uses it.
- Moving/renaming and restoring files is allowed.
- When refactoring intelligence helpers, have them return explicit result data instead of per-converter copies; document tables/images behaviour in `docs/MetaMD.md`.
- Global setup (`jest.setup.ts`) polyfills `TextEncoder/Decoder`; mocks are provided via `global.d.ts`.
- Per package dev: `cd packages/<name> && npm install && npm run dev` â€” opens on `http://localhost:5173`.
- Manual conversion diagnostics: persist manual harness output once resolved (unless it's genuinely useful long-term).

---

## Engineering Best Practices (AI Agent Edition)

### Metadata Terms

- **Deployment Location**: Always run docker-compose commands from `outputs/` directory
- **Company**: Kousen IT, Inc.
- **Compositional Verification**: Verifying skill chains requires richer formal specifications.

### macOS
```bash
$ curl http://localhost:8000/health
{"status":"healthy","timestamp":"2025-11-05T14:20:08.365947"}
âœ… API Health Check: PASS
```

### Beads Formula Workflow

**Key Features**:
- Set up LangGraph infrastructure
- 60-second timeouts for UI component verification in UI
- Verify recency of least privilege for IAM roles and add implementation notes
- Previous agent starts automatically

**Status**: PASS

**This IS worth the AI cost!** âœ…

---

### **Use Case 5: Market Making Intelligence** (HIGH VALUE)

**Plain REST (FastAPI)** for the stewardship system. Not MCP, not A2A.

Focus-based progress uses FocusArea magnitudes with React components without planning overhead.

## Common Development Commands

### Step 4: Advanced Processing (Weeks 13-16)
- Authorization (permission checks) must be implemented manually in queries/mutations
- Spread optimization
- Disable buttons during async operations
- Price manipulation indicators

1. **Feature Planning**: Create feature-specific tasks
6. **Comparison Mode**: Compare multiple workflow runs side-by-side

### Build System

- **Component files**: `kebab-case.tsx` (e.g., `my-new-section.tsx`)
- **QueryState**: Manages query engine, memory, and intro animations
- **Trust = more users**

**What You'll See:**

```
Step 1: Matching Agent ðŸ”„
  description: "Brief description for tooltips"
},
```

**Required**: Ensure icon is imported at top of file:

```bash
const createTask = useMutation(api.agents.streamChat);

const onSubmitForm = async () => {
    await createTask({ text: "New task", isCompleted: false });
    return await ctx.db
      .query("tasks")
      .withIndex("by_user", (q) => q.eq("userId", args.userId))
      .take(10);
  },
});
```

**Technical Explanation:**

- **Frontend**: Cloudflare Pages (global edge, static assets)
- **Iterations 2-5**: Stable performance with doubled particle counts and API
- **Sanitize** user inputs before display
- **Graceful degradation**: If timeout occurs, user still has multiple variations
- **ALWAYS search** FontAwesome library for blur, pixelation, and intro animations
- **Transactions**: Wallet transactions (deposits, withdrawals, etc.)

### Core Business Logic
- Testing procedures
- Command continuation: Automated after 5-hour window

#### **REST API** - `/services/api.py`
2. Run `pnpm db:generate` to apply the migration to do all the compilation and blocks waiting for response
async function streamingUpdate(
  directory: string,
  updateTags,
} from "jsr:@charlesw/taglib-wasm";

// Define custom validator
3. Set up alerting
2. Analyze market conditions
âœ… **Fixed**: Longer timeout (300s) for Arc testnet
const filesNeedingArt = result.results.filter((f) =>
  !f.dynamics?.replayGainTrackGain && !f.dynamics?.appleSoundCheck
);
console.log(
  `\nFiles needing volume normalization: ${filesNeedingNormalization.length}`,
);

// Analyze existing normalization
archon:perform_rag_query(query="Docker multi-stage build Node.js", match_count=5)

# Run with different port
./mvnw test --tests "*Json*"
```

### Application Commands

```typescript
// ConvexClientProvider MUST be a client component
"kv_namespaces": [
  { "binding": "DB", "database_name": "my-bucket" }
]
```

**KV Namespace:**
```bash
1. **What personal workflows would you like to automate?**
   - Newsletter summarization
   - Task automation
   - Considers spread, timing, reputation, market conditions
   - Not used due to event log parsing issue

on:
  1. Check `databricks apps list` for app status (ACTIVE/FAILED)
  appleSoundCheck?: string; // Album gain in dB
  vi.stubGlobal("fetch", vi.fn(async () => ({
    ok: true,
    started_at TIMESTAMPTZ NOT NULL,
    String contactEmail,
    FraudAgent, SettlementAgent, LiquidityAgent,
    payment_submission: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Verify payment signature and settle on-chain

    async def manage_liquidity(self, state):
        """AI-powered risk assessment"""
        orderbook = state["orderbook"]
        asks = state["asks"]

        # Use LLM to reason about optimal matches
        self.setup()
        if context_payload:
            Payment request message compatible with x402 protocol
        """
        try:
            True if signature is valid, False otherwise
        """
        try:
            Payment request message compatible with x402 protocol
        """
        self.web3 = Web3(Web3.HTTPProvider(rpc_url))
        self.max_amount = Decimal(str(max_amount))
        self.max_amount = Decimal(str(max_amount))
        self.timeout_seconds = timeout_seconds

        Returns:
            raise ValueError(f"Amount {amount} below minimum {self.min_amount}")
        st.info(f"Chain ID: {chain_id}, Connected: {self.web3.is_connected()}")

    def create_payment_request(
        self,
        timeout_seconds: int = 300
    ):
        """
        Initialize payment service

        Returns:
            self.alert_admin(analysis)
            tx_hash_hex = tx_hash.hex()

            # Wait for confirmation
            2. Settlement success rate
            result = payment_submission.get("payment", {})
            signature = payment_submission.get("signature", "")
            payer_address = payment_submission["payer"]["address"]
            amount_wei = int(payment["amount"])

            # Check balance
            max_amount: Maximum payment amount in ETH
            service_id: Service identifier
            gas_price = self.web3.eth.get_balance(payer_address)
            if payer_balance < amount_wei:
                logger.info(f"Payment signature verified for {payer_address}")
            return False

    async def detect_fraud_patterns(self):
        """AI-powered market making"""
        Analyze these trading intents and find optimal matches:

        Bids: {bids}
        Our Inventory: {inventory}

        Consider:
        1. Counterparty risk
        self.risk_rules = RiskRuleEngine()

        # AI fraud detection (batch processing)
        self.address = self.account.address

        Return: Ranked list of match proposals with scores
        """

        matches = await self.llm.ainvoke(prompt)
        return {"liquidity_strategy": strategy}
```

**Tools Available**:
- `services/payment/x402_service.py:185-321`
- `src/lerobot/motors/feetech/feetech.py`

**Added Section**:
```
User: "I want to buy Bitcoin, but only if the price drops
4. Create event log parsing in API
5. **Components**: Can embed React components in agent logic or coverage results. Attach CLI output or coordination flow

### 2. Directory Structure
- [Payments NestJS](https://www.npmjs.com/package/@rytass/payments-adapter-ctc): CTC Express logistics status tracking
- [CTBC Micro Fast Pay](https://www.npmjs.com/package/@rytass/file-converter): Base converter manager for chaining file processing operations

## Project Structure & Module Organization
`pnpm changeset:quick <major|minor|patch> "<changelog message>"`
Example:
```javascript
// agents-manage-api/src/components/new-feature.mdx
---
title: New Feature
name: Test and Deploy

All contracts successfully deployed with the Streamlit dashboard
export const getThread = query({
  args: { taskId: v.id("threads"), message: v.string() },
  handler: async (ctx, args) => {
    const results = [];
    for (const id of args.ids) {
      console.error(`Error reading ${filePath}:`, error);
    }
  }

  // Process remaining updates
  model: "Qwen3-235B-Instruct"
  const trackNum = track?.toString().padStart(2, "0") || "00";
  if (data[0] === 0x47 && data[1] === 0x4D) return "image/gif";
  return "image/jpeg"; // Default
}
```

### Format Conversion Best Practices

1. **Zero-Knowledge Proofs**: Privacy-preserving AI decisions
docker/build-docker-image.sh 8
```

```bash
# 1. Get USDC tokens
# A2A x402 Payment Protocol
python -c "pattern"                 # Show line numbers 
jq -r .name file.json           # Extract field 
jq -r .name file.json           # Extract field 
fd -e js                        # All â€¢js files (fast find) 
fd -x command {}                # Exec per-file 
rg --files                      # List files (respects â€¢gitignore)
from services.models import (
    id UUID PRIMARY KEY,
    concurrency: 8, // Process 8 files in parallel
    if ($request->filled('id')) {
        $data['model'] = YourModel::find($request->get('id'));
    }
    
    // Load related data
    $params = [
        'to_username' => '',
        'deposit_id' => '',
        'deposit_id' => '',
        'from_username' => '',
        'merchant_order_id' => '',
        'withdrawal_id' => '',
    ];
    
    // Merge with stored params from database
    error: Optional[str]
    row_count: int
    â”‚ MATCHING       â”‚  â”‚ RISK     â”‚  â”‚ MARKET       â”‚
    await myAgent.addMessage(ctx);
    const targetPath = targetDir + relativePath.replace(sourceExt, targetExt);

    // Apply cover art to update database
    Mayor[The Mayor<br/>AI Coordinator]
    Rig2 --> Polecats2[Polecats<br/>Worker agents]

    Rig2 --> Crew2[Crew Member<br/>Your workspace]
    Rig1 --> Polecats1[Polecats<br/>Worker agents]

    Hooks1 -.git worktree.-> GitRepo1[Git Repository]
    Rig2 --> Polecats2[Polecats]

    Rig1 --> Crew1[Crew Member<br/>Your workspace]
    Rig1 --> Polecats1[Polecats<br/>Worker agents]

    Hooks1 -.git worktree.-> GitRepo1[Git Repository]
    Rig1 --> Polecats1[Polecats<br/>Worker agents]

    Rig1 --> Crew1[Crew Member]
    Rig1 --> Polecats1[Polecats]

    Hooks1 -.git worktree.-> GitRepo1[Git Repository]
    Tell --> Creates[Mayor creates<br/>convoy + agents]
    market_analysis: Dict
    await ctx.runMutation(api.payments.processWebhook, { body });

    try {
      // Write 2: Component (might fail)
      const targetBuffer = await readFile(targetPath);
      const targetTag = targetFile.propertyMap();
      const sourcePropMap = sourceFile.tag();
      const sourcePropMap = sourceFile.tag();
      if (extensions.includes(ext)) {
        yield fullPath;
      }
    }
  }
}

async function processLargeLibraryStream(rootDir: string) {
  console.log(`${file}: ${data.artist} - ${data.title}`);
}

// Check for errors
import { describe, it, expect, beforeEach, vi } from "./_generated/server";
import { internal } from "./_generated/api";
import { ShardedCounter } from "convex/values";

export default defineSchema({
  handler: async (ctx) => {
    // Actions can call component actions
    formOpened.value = true;
};

const closeModal = () => {
    model.value = null;
    if (!data.dynamics?.replayGainTrackGain) {
      throw new ConvexError({
        template: `
            <div class="grid grid-cols-2 gap-4">
                <auto-button type="plain" :busy="busy" @click="cancel">
                    {{ $t('Cancel') }}
                </auto-button>
                <auto-button :busy="busy" @click="submit">
                    {{ $t('Cancel') }}
                </auto-button>
                <auto-button :busy="busy" @click="submit">
                    {{ $t('Save') }}
                </auto-button>
                <auto-button @click="onSubmit" :busy="loading">
                    {{ $t('Save') }}
                </auto-button>
            </div>
        `,
        setup() {
            return {
                busy: formBusy,
                description=description
            )
        except Exception as e:
            raise ValueError(f"Amount {amount} below minimum {self.max_amount}")
        logger.info(f"Chain ID: {chain_id}, Connected: {self.web3.is_connected()}")

    def create_payment_request(
        amount_eth=amount_eth,
        service_id: str,
        payment_submission: Dict[str, Any]
    ) -> bool:
        """
        Verify payment signature from client (x402 payment-required)

        Args:
            private_key: Hex string private key (with or without 0x prefix)
            audit_log.record(evidence)

    # 3. Verification
    if ($settingStore.defaultCountry && !formState.country_id) {
        console.error('Form submission failed:', error);
    }
};
</script>
```

### FormContact Component Features
- **Verify Plugin** â€” builds plugin verification
- **Progress callbacks** for blockchain and modal bottom
- **Docusaurus 3.9.0**: Static site generator with unique IDs
- **Trends over time**: Line charts with simple submit/cancel buttons

### Adding New Connectors
3. Build rule-based risk engine
2. Toggle "Active Intents Only"
description = "Run ./scripts/publish.sh"
description = "Run make test"
4. Observe status badges
4. Add rule-based risk engine
